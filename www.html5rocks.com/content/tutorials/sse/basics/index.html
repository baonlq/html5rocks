{% extends "../../../../templates/sample.html" %}

{% block headauthor %}Eric Bidelman <e.bidelman@chromium.org>{% endblock %}
{% block pageauthor %}Eric Bidelman{% endblock %}
{% block headtitle %}Server-Sent Events{% endblock %}
{% block pagetitle %}Server-Sent Events{% endblock %}
{% block pagebreadcrumb %}Server-Sent Events{% endblock %}
{% block head %}
<style>
</style>
{% endblock %}
{% block date %}November 3, 2010{% endblock %}

{% block browsersupport %}
<span class="opera supported"></span>
<span class="ie"></span>
<span class="safari supported"></span>
<span class="ff"></span>
<span class="chrome supported"></span>
{% endblock %}

{% block iscompatible %}
  return !!window.EventSource;
{% endblock %}

{% block content %}
  <h2 id="toc-introduction">Introduction</h2>
  <p>I wouldn't be surprised if you've stumbled upon this article wondering what the heck
  <a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events</a> (SSEs) are. Many people
  have never heard of them, and rightfully so. The specification has been plagued by significant
  changes over the years and has taken somewhat of a backseat to newer, sexier communication
  protocols such as the <a href="/tutorials/#websockets">WebSocket API</a>.

  <h3 id="toc-introduction-differences">Server-Sent Events vs. WebSockets</h3>

  <p>The main question is why would you choose Server-Sent Events over WebSockets? Good question!
  Lets go through some background:</p>

  <ol>
  <li>If you're familiar with the HTTP protocol, you know that fetching data
  accomplished with a request/response format. The client makes a request and waits for the
  server to respond with some data. OK, simple enough. The same is not truth with SSEs. When communicating
  using SSEs, a server can send data to your app whenever it wants, without the need for the client
  to make that initial request. Think server push. SSEs open a single unidirectional connection
  channel between server and client. Updates can be pushed from the server to the client
  as they happen. The result is that COMET techniques like XHR polling and hanging GETs
  (which create greater HTTP overhead) are no longer needed.</li>

  <li>One of the reasons SSEs have been held in the shadow is because
  other APIs such as the <a href="/tutorials/#websockets">WebSocket API</a> were defined later on
  and provide a protocol to perform bi-directional, full-duplex communication between
  client/server. Having a two-way communication channel is ideal
  for things like games, messaging apps, and for cases where you need near-realtime updates in both
  directions. However, in some scenarios data doesn't need to be sent to the server. Your client simply
  needs updates from some action. A few examples would be friends' status stream, stocker tickers,
  news updates, or other automated data push mechanisms (e.g. updating Web SQL Database).</li>

  <li>Lastly, SSEs are sent over traditional HTTP and do not require a special protocol or server
  implementation to get working. WebSockets on the other hand, require full-duplex connections
  and new Web Socket servers to handle the protocol. In addition, Server-Sent Events  have a variety
  of features that WebSockets lack by design such as automatic reconnection, event IDs,
  and the ability to send arbitrary events.</li>
  </ol>

  <h2 id="toc-gettingstarted">Getting Started</h2>

  <p>Blah</p>

  <pre class="prettyprint">
var source = new EventSource('source.php');

source.addEventListener('message', function(event) {
  console.log(event.data)
}, false);

source.addEventListener('open', function(event) {
  // Connection was opened.
}, false);

source.addEventListener('error', function(event) {
  if (event.eventPhase == EventSource.CLOSED) {
    // Connection was close.
  }
}, false);
</pre>

  <p>A simple server implementation in PHP:</p>

<pre class="prettyprint">
&lt;?php
header('Content-Type: text/event-stream');

/**
 * Constructs the SSE data format and flushes that data to the client.
 *
 * @param string $id Timestamp/id of this connection.
 * @param string $msg Line of text that should be transmitted.
 */
function sendMsg($id, $msg) {
  echo "id: $id" . PHP_EOL;
  echo "data: $msg" . PHP_EOL;
  echo PHP_EOL;
  flush();
}

$startedAt = time();

do {
  // Cap connections at 10 seconds. The browser will reopen the connection on close
  if ((time() - $startedAt) > 10) {
    die();
  }

  sendMsg($startedAt , 'server time: ' . date("h:i:s", time()));
  sleep(3);

  // If we didn't use a while loop, the browser would essentially do polling
  // every ~3 seconds. Using the while, we keep the connection open and only make
  // one request.
} while(false);
?&gt;
</pre>

  <p>Blah</p>

  <h2 id="toc-references">References</h2>
  <ul>
    <li><a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events</a> specification</li>
  </ul>

<script>
</script>
{% endblock %}
