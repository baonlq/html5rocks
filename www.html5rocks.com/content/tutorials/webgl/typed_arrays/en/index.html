{% extends "tutorial.html" %}

{% block html5badge %}
<img src="/static/images/identity/html5-badge-h-graphics.png" width="133" height="64" alt="This article is powered by HTML5 Graphics, 3D &amp; Effects" title="This article is powered by HTML5 Graphics, 3D &amp; Effects" />
{% endblock %}

{% block iscompatible %}
  return !!window.ArrayBuffer;
{% endblock %}

{% block content %}

<h2 id="toc-intro">Introduction</h2>

<p>Typed Arrays are a relatively recent addition to browsers, born out of the need to have an efficient way to handle binary data in WebGL. A Typed Array is a slab of memory with a typed view into it, much like how arrays work in C. Because a Typed Array is backed by raw memory, the JavaScript engine can pass the memory directly to native libraries without having to painstakingly convert the data to a native representation. As a result, typed arrays perform a lot better than JavaScript arrays for passing data to WebGL and other APIs dealing with binary data.

<p>The Typed Arrays spec defines three types of objects that you can use to create and manipulate Typed Arrays. The core object in the spec is the ArrayBuffer, a slab of raw memory. You can only query the byteLength of an ArrayBuffer and slice it to create copies of a subset of the ArrayBuffer. To access the contents of an ArrayBuffer, you need to use a view object. There are two types of views: typed array views and DataViews.

<p>Typed array views act like single-type arrays to a segment of an ArrayBuffer. There are views for all the usual numeric types, with self-descriptive names like Float32Array, Float64Array, Int32Array and Uint8Array. There's also a special view which has replaced the pixel array type in Canvas's ImageData: Uint8ClampedArray.

<p>DataView is the second type of view and it is meant for handling heterogeneous data. Instead of having an array-like API, the DataView object provides you a get/set API to read and write arbitrary data types at arbitrary byte offsets. DataView works great for reading and writing file headers and other such struct-like data.


<h2 id="toc-basics">Basics of using Typed Arrays</h2>

<h3 id="toc-abv">Typed array views</h3>

<p>To use Typed Arrays, you need to create an ArrayBuffer and a view to it. The easiest way is to create a typed array view of the desired size and type.

<pre class="prettyprint">
var f64a = new Float64Array(8);
// Typed array views work pretty much like normal arrays.
f64a[0] = 10;
f64a[1] = 20;
f64a[2] = f64a[0] + f64a[1];
</pre>

<p>There are several different types of typed array views. They all share the same API, so once you know how to use one, you pretty much know how to use them all. I'm going to create one of each currently existing typed array views in the next example.

<pre class="prettyprint">
// Floating point arrays.
new Float64Array(8);
new Float32Array(16);

// Signed integer arrays.
new Int64Array(8);
new Int32Array(16);
new Int16Array(32);
new Int8Array(64);

// Unsigned integer arrays.
new Uint64Array(8);
new Uint32Array(16);
new Uint16Array(32);
new Uint8Array(64);
new Uint8ClampedArray(64);

// The last one is a bit special, it clamps input values between 0 and 255.
</pre>

<p>You can also create an ArrayBuffer first and then create views that point to it.

<pre class="prettyprint">
var ab = new ArrayBuffer(256); // 256-byte ArrayBuffer.
var faFull = new Uint8Array(ab);
var faFirstHalf = new Uint8Array(ab, 0, 128);
var faThirdQuarter = new Uint8Array(ab, 128, 128);
var faRest = new Uint8Array(ab, 192);
</pre>

<p>You can also have several views to the same ArrayBuffer.

<pre>
var fa = new Float32Array(64);
var ba = new Uint8Array(fa.buffer, 0, Float32Array.BYTES_PER_ELEMENT); // First float of fa.
</pre>

<h3 id="toc-dataview">DataView</h3>

<p>To use ArrayBuffers that contain data with heterogenous types, the easiest way is to use a DataView to the buffer. Suppose we have a file format that has a header with an 8-bit unsigned int followed by two 16-bit ints, followed by a payload array of 32-bit floats. Reading this back with typed array views is doable but a bit of a pain. With a DataView we can read the header and use an typed array view for the float array.

<pre class="prettyprint">
var dv = new DataView(buffer);
var vector_length = dv.getUint8(0);
var width = dv.getUint16(1); // 0+uint8 = 1 bytes offset
var height = dv.getUint16(3); // 0+uint8+uint16 = 3 bytes offset
var vectors = new Float32Array(width*height*vector_length);
for (var i=0, off=5; i&lt;vectors.length; i++, off+=4) {
  vectors[i] = dv.getFloat32(off);
}
</pre>

<p>In the above example, all the values I read are big-endian. If the values in the buffer are little-endian, you can pass the optional littleEndian parameter to the getter:

<pre class="prettyprint">
...
var width = dv.getUint16(1, true);
var height = dv.getUint16(3, true);
...
vectors[i] = dv.getFloat32(off, true);
...
</pre>

<p>Note that typed array views are always in the native byte order. This is to make them fast. You should use a DataView to read and write data where endianness is going to be an issue.

<p>The DataView also has methods for writing values to buffers. These setters are named in the same fashion as the getters, "set" followed by the data type.

<pre class="prettyprint">
dv.setInt32(0, 25, false); // set big-endian int32 at byte offset 0 to 25
dv.setInt32(4, 25); // set big-endian int32 at byte offset 4 to 25
dv.setFloat32(8, 2.5, true); // set little-endian float32 at byte offset 8 to 2.5
</pre>

<h3 id="toc-endianness">What is endianness</h3>

<p>Endianness is the order in which multi-byte numbers are stored in the computer's memory. Think of it like your usual base-10 numbers. Writing one thousand and twenty-six in big-endian would come out 1026, but writing it in little-endian would give you 6201. Most CPUs out there (like the one in your mobile phone) use big-endian numbers, but the x86 architecture used in laptops and desktop computers uses little-endian numbers.

<p>When you're writing code that reads and writes data and you don't want to be tied to a single CPU architecture, you need to do your reads and writes in a fashion that takes endianness into account. So instead of just XHRing your data into an typed array view, read it into the array using a DataView. Ditto for sending data to the server.

<p>If you really want to run with scissors, the following example demonstrates how to detect endianness on the browser. You can use the result to XHR in data in the native endian format (and avoid some JS work) or to skip the endianness conversion if the data's endianness matches the browser's (again, saving some JS work). Right. So, here's how to detect if your browser is little-endian:

<pre class="prettyprint">
var littleEndian = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
</pre>

<p>DataView is a recent (as of June 2012) addition to the Typed Arrays spec, so it's not available on older browsers, not to mention browsers that don't support Typed Arrays. For those browsers, you can use jDataView, which is a third-party library that implements the DataView spec with some additions of its own like maintaining a seek pointer to do a file-like reads and writes.

<h2 id="toc-browserapis">Browser APIs that use Typed Arrays</h2>

<p>I'm going to give you a brief overview of the different browser APIs that are currently using Typed Arrays. The current crop includes WebGL, Canvas, Web Audio API, XMLHttpRequests, WebSockets, Web Workers, Media Source API and File APIs. From the list of APIs you can see that Typed Arrays are well suited for performance-sensitive multimedia work as well as passing data around in an efficient fashion.

<h3 id="toc-webgl">WebGL</h3>

<p>The first use of Typed Arrays was in WebGL, where it is used to pass around buffer data and image data. To set the contents of a WebGL buffer object, you use the gl.bufferData() call with a Typed Array.

<pre class="prettyprint">
var floatArray = new Float32Array([1,2,3,4,5,6,7,8]);
gl.bufferData(gl.ARRAY_BUFFER, floatArray);
</pre>

<p>Typed Arrays are also used to pass around texture data. Here's a basic example of passing in texture content using a Typed Array.

<pre class="prettyprint">
var pixels = new Uint8Array(16*16*4); // 16x16 RGBA image
gl.texImage2D(
  gl.TEXTURE_2D, // target
  0, // mip level
  gl.RGBA, // internal format
  16, 16, // width and height
  0, // border
  gl.UNSIGNED_BYTE, // type
  pixels // texture data
);
</pre>

<p>You also need Typed Arrays to read pixels from the WebGL context.

<pre class="prettyprint">
var pixels = new Uint8Array(320*240*4); // 320x240 RGBA image
gl.readPixels(0, 0, 320, 240, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
</pre>

<h3 id="toc-canvas2d">Canvas 2D</h3>

<p>Recently the Canvas ImageData object was made to work with the Typed Arrays spec. Now you can get a Typed Arrays representation of the pixels on a canvas element. This is helpful since now you can also create and edit canvas pixel arrays without having to fiddle around with the canvas element.

<pre class="prettyprint">
var imageData = ctx.getImageData(0,0, 200, 100);
var typedArray = new Uint8ClampedArray(imageData.data);
</pre>

<h3 id="toc-xhr2">XMLHttpRequest2</h3>

<p>XMLHttpRequest got a Typed Array boost and now you can receive a Typed Array response instead of having to parse a JavaScript string into a Typed Array. This is really neat for passing fetched data directly to multimedia APIs and for parsing binary files fetched from the network.

<p>All you have to do is set the responseType of the XMLHttpRequest object to 'arraybuffer'.

<pre class="prettyprint">
xhr.responseType = 'arraybuffer';
</pre>

<h3 id="toc-fileapis">File APIs</h3>

<p>The FileReader can read file contents as an ArrayBuffer. You can then attach typed array views and DataViews to the buffer to manipulate its contents.

<pre class="prettyprint">
reader.readAsArrayBuffer(file);
</pre>

<h3 id="toc-webworkers">Web Workers Transferable objects</h3>

<p>Transferable objects in Web Workers make passing binary data to Web Workers a great deal faster. When you send an object to a Worker as a Transferable, the object becomes inaccessible in the sending thread and the receiving Worker gets ownership of the object. This allows for a highly optimized implementation where the sent data is not copied, just the ownership of the Typed Array is transferred to the receiver.

<p>To use Transferable objects with Web Workers, you need to use the webkitPostMessage or operaPostMessage method on the worker. The second argument to it is the array of objects you wish to transfer to the worker.

<pre class="prettyprint">
worker.webkitPostMessage(oneGBTypedArray, [oneGBTypedArray]);
</pre>

<p>To get the objects back from the worker, the worker can pass them back to the main thread in the same fashion.

<pre class="prettyprint">
webkitPostMessage({results: grand, youCanHaveThisBack: oneGBTypedArray}, [oneGBTypedArray]);
</pre>

<p>Zero copies, woo!

<h3 id="toc-mediasource">Media Source API</h3>

<p>Recently, the media elements also got some Typed Array goodness. You can directly pass a Typed Array containing video data to a video element using webkitSourceAppend. This makes the video element append the video data after the existing video. SourceAppend is awesome for doing interstitials, playlists, streaming and other uses where you might want to play several videos using a single video element.

<pre class="prettyprint">
video.webkitSourceAppend(uint8Array);
</pre>

<h3 id="toc-websockets">Binary WebSockets</h3>

<p>You can also use Typed Arrays with WebSockets to avoid having to stringify all your data. Great for writing efficient protocols and minimizing network traffic.

<pre class="prettyprint">
socket.binaryType = 'arraybuffer';
</pre>

<p>Whew! That wraps up the API review. Let's move onto looking at third-party libraries for handling Typed Arrays.

<h2 id="toc-thirdparty">Third-party libraries</h2>

<h3 id="toc-jdataview">jDataView</h3>

<p><a href="https://https://github.com/vjeux/jDataView">jDataView</a> implements a DataView shim for all browsers. DataView used to be a WebKit-only feature, but now it's supported by most other browsers. The Mozilla developer team is in the process of landing a patch to enable DataView on Firefox as well.

<h3 id="toc-stringencoding">stringencoding</h3>

<p>Working with strings in Typed Arrays is a bit of a pain at the moment, but there’s the stringencoding library that helps there. Stringencoding implements the proposed Typed Array string encoding spec, so it’s also a good way to get a feel for what’s coming.

<p>Here's a basic usage example of stringencoding:

<pre class="prettyprint">
var uint8array = new TextEncoder(encoding).encode(string);
var string = new TextDecoder(encoding).decode(uint8array);
</pre>

<h3 id="toc-bitview">BitView.js</h3>

<p>I have written a small bit manipulation library for Typed Arrays called BitView.js. As the name says, it works much like the DataView, except it works with bits. With BitView you can get and set the value of a bit at a given bit offset in an ArrayBuffer. BitView also has methods for storing and loading 6-bit and 12-bit ints at arbitrary bit offsets.

<p>12-bit ints are nice for working with screen coordinates, as displays tend to have fewer than 4096 pixels along the longer dimension. By using 12-bit ints instead of 32-bit ints, you get a 62% size reduction. For a more extreme example, I was working with Shapefiles that use 64-bit floats for the coordinates, but I didn't need the precision because the model was only going to be shown at screen size. Switching over to 12-bit base coordinates with 6-bit deltas to encode changes from the previous coordinate brought the filesize down to a tenth. You can see the demo of that at <a href="http://fhtr.org/shp.js/">here</a>.

Here's an example of using BitView.js:

<pre class="prettyprint">
var bv = new BitView(arrayBuffer);
bv.setBit(4, 1); // Set fourth bit of arrayBuffer to 1.
bv.getBit(17); // Get 17th bit of arrayBuffer.

bv.getBit(50*8 + 3); // Get third bit of 50th byte in arrayBuffer.

bv.setInt6(3, 18); // Write 18 as a 6-bit int to bit position 3 in arrayBuffer.
bv.getInt12(9); // Read a 12-bit int from bit position 9 in arrayBuffer.
</pre>

<h3 id="toc-datastream">DataStream.js</h3>

<p>One of the most exciting things about typed arrays is how they make it easier to deal with binary files in JavaScript. Instead of parsing a string character by character and manually converting the characters into binary numbers and such, you can now get an ArrayBuffer with XMLHttpRequest and directly process it using a DataView. This makes it easy to e.g. load in an MP3 file and read the metadata tags for use in your audio player. Or load in a shapefile and turn it into a WebGL model. Or read the EXIF tags off a JPEG and show them in your slideshow app.

<p>The problem with ArrayBuffer XHRs is that reading struct-like data from the buffer is a bit of a pain. DataView is good for reading a few numbers at a time in an endian-safe fashion, typed array views are good for reading arrays of element-size-aligned native endian numbers. What we felt missing is a way to read in arrays and structs of data in a convenient endian-safe fashion. Enter DataStream.js.

<p><a href="http://github.com/kig/DataStream.js">DataStream.js</a> is a Typed Arrays library that read and writes scalars, strings, arrays and structs of data from ArrayBuffers in a file-like fashion.

<p>Example of reading in an array of floats from an ArrayBuffer:

<pre class="prettyprint">
// without DataStream.js
var dv = new DataView(buffer);
var f32 = new Float32Array(buffer.byteLength / 4);
var littleEndian = true;
for (var i = 0; i&lt;f32.length; i++) {
  f32[i] = dv.getFloat32(i*4, littleEndian);
}

// with DataStream.js
var ds = new DataStream(buffer);
ds.endianness = DataStream.LITTLE_ENDIAN;
var f32 = ds.readFloat32Array(ds.byteLength / 4);
</pre>

<p>Where DataStream.js gets really useful is in reading more complex data. Suppose you have a method that reads in JPEG markers:

<pre class="prettyprint">
// without DataStream.js
var dv = new DataView(buffer);
var objs = [];
for (var i=0; i&lt;buffer.byteLength;) {
  var obj = {};
  obj.tag = dv.getUint16(i);
  i += 2;
  obj.length = dv.getUint16(i);
  i += 2;
  obj.data = new Uint8Array(obj.length - 2);
  for (var j=0; j&lt;obj.data.length; j++,i++) {
    obj.data[j] = dv.getUint8(i);
  }
  objs.push(obj);
}

// with DataStream.js
var ds = new DataStream(buffer);
ds.endianness = ds.BIG_ENDIAN;
var objs = [];
while (!ds.isEof()) {
  var obj = {};
  obj.tag = ds.readUint16();
  obj.length = ds.readUint16();
  obj.data = ds.readUint8Array(obj.length - 2);
  objs.push(obj);
}
</pre>

<p>Or use the DataStream.readStruct method to read in structs of data:

<pre class="prettyprint">
// with DataStream.readStruct
ds.readStruct([
  'objs', ['[]', [ // objs: array of tag,length,data structs
    'tag', 'uint16',
    'length', 'uint16',
    'data', ['[]', 'uint8', function(s,ds){ return s.length - 2; }], // get length with a function
  '*'] // read in as many struct as there are
]);
</pre>

<p>You can see a live example of reading in JPEG metadata <a href="http://fhtr.org/DataStream.js/jpeg.html">here</a>.

<h2 id="toc-history">History of Typed Arrays</h2>

<p>Typed Arrays got their start in the early implementation stage of WebGL, when we found that passing JavaScript arrays to the graphics driver was causing performance problems. With JavaScript arrays, the WebGL binding had to allocate a native array and fill it by walking over the JavaScript array and cast every JavaScript object in the array to the required native type.

<p>To fix the data conversion bottleneck, Mozilla's Vladimir Vukicevic wrote CanvasFloatArray: a C-style float array with a JavaScript interface. Now you could edit the CanvasFloatArray in JavaScript and pass it directly to WebGL without having to do any extra work in the binding. In further iterations, CanvasFloatArray was renamed to WebGLFloatArray, which was further renamed to Float32Array and split into a backing ArrayBuffer and the typed Float32Array-view to access the buffer.

<h2 id="toc-design">Design considerations</h2>

<p>From the beginning, the design of Typed Arrays was driven by the need to efficiently pass binary data to native libraries. For this reason, the Typed Arrays spec doesn't do automatic endianness conversions, pixel [un]premultiplying, color space conversions or any other such higher-level data operations. To handle endianness, the spec has a DataView object for reading and writing numbers with the wanted endianness.

<h2 id="toc-references">References</h2>

<ul>
<li><a href="http://www.khronos.org/registry/typedarray/specs/latest/">Typed Array Specification</a>
<li><a href="https://github.com/vjeux/jDataView">jDataView</a>
<li><a href="https://github.com/kig/DataStream.js">DataStream.js</a>
<li><a href="https://github.com/kig/BitView.js">BitView.js</a>
<li><a href="http://code.google.com/p/stringencoding/">stringencoding</a>
<li><a href="http://blog.gingertech.net/2011/10/">On webkitSourceAppend</a>
</ul>

{% endblock %}
