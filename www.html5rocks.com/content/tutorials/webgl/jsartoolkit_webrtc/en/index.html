{% extends "tutorial.html" %}

{% block html5badge %}
<img src="/static/images/identity/html5-badge-h-graphics.png" width="133" height="64" alt="This article is powered by HTML5 Graphics, 3D &amp; Effects" title="This article is powered by HTML5 Graphics, 3D &amp; Effects" />
{% endblock %}

{% block iscompatible %}
  return !!Modernizr.webgl && navigator.webkitGetUserMedia
{% endblock %}

{% block content %}

<h2 id="toc-intro">Introduction</h2>
<p>This article is about using the <a href="https://github.com/kig/JSARToolKit">JSARToolKit</a> library with <a href="http://webrtc.org">WebRTC</a> to do augmented reality applications on the web. For rendering, I'm using WebGL due to the increased performance it offers. The end result of this article is a demo application that puts a 3D model on top of an augmented reality marker in webcam video.

<p>JSARToolKit is an augmented reality library for JavaScript. It's an open source library released under the GPL. JSARToolKit is a direct port of the Flash <a href="http://www.libspark.org/wiki/saqoosha/FLARToolKit/en">FLARToolKit</a> that I made for the Mozilla <a href="https://developer.mozilla.org/en-US/demos/detail/remixing-reality/launch">Remixing Reality demo</a>. FLARToolKit itself is port of the Java <a href="http://nyatla.jp/nyartoolkit/wp/">NyARToolKit</a>, which is a port of the C <a href="http://www.hitl.washington.edu/artoolkit/">ARToolKit</a>. Long way, but here we are. 

<p>JSARToolKit operates on canvas elements. As it needs to read the image off the canvas, the image needs to come from the same origin as the page or use CORS to get around same-origin policy. When you pass a canvas to JSARToolKit for analysis, JSARToolKit returns a list of AR markers found in the image and the corresponding transformation matrices. To draw a 3D object on top of a marker, you pass the transformation matrix to whatever 3D rendering library you're using so that your object is transformed using the matrix. Draw the video frame in your WebGL scene and draw the object on top of that and you're good to go.

<p>To analyze video using the JSARToolKit, draw the video on a canvas, then pass the canvas to JSARToolKit. Do this for every frame and you've got video AR tracking. JSARToolKit is fast enough on modern JavaScript engines to do this in realtime even on 640x480 video frames. However, the larger the video frame, the longer it takes to process. A good video frame size is 320x240, but if you expect to use small markers or multiple markers, 640x480 is preferable.

<h2 id="toc-videodemo">Demo</h2>

<p>To view the webcam demo, you need to have WebRTC enabled in your browser (on Chrome, go the about:flags and enable MediaStream). You also need to print out the AR marker below. You can try opening the marker image on your phone or tablet and showing it to the webcam.

<figure>
  <img src="marker.png">
  <figcaption>
    AR marker.
  </figcaption>
</figure>

<p>Here is a demo of what we're aiming for. This demo creates an image slideshow using AR markers. Show a marker to the camera and it will have a photo on it. Move the marker out of the camera's view and show it again and the image has changed.

<figure>
  <img src="AR_slideshow.jpg">
  <figcaption>
    <a href="AR_mediaStream.html">AR webcam demo</a> (if you don't have WebRTC, here's a <a href="AR_slideshow.html">version with pre-canned video</a>)
  </figcaption>
</figure>


<h2 id="toc-setup">Setting up JSARToolKit</h2>
<p>The JSARToolKit API is quite Java-like, so you'll have to do some contortions to use it. The basic idea is that you have a detector object that operates on a raster object. Between the detector and the raster is a camera parameter object that transforms raster coordinates to camera coordinates. To get the detected markers from the detector, you iterate over them and copy their transformation matrices over to your code. 

<p>The first step is to create the raster object, the camera parameter object and the detector object.

<pre class="prettyprint">
// Create a RGB raster object for the 2D canvas.
// JSARToolKit uses raster objects to read image data.
var raster = new NyARRgbRaster_Canvas2D(canvas);

// FLARParam is the thing used by FLARToolKit to set camera parameters.
// Here we create a FLARParam for images with 320x240 pixel dimensions.
var param = new FLARParam(320,240);

// The FLARMultiIdMarkerDetector is the actual detection engine for marker detection.
// It detects multiple ID markers. ID markers are special markers that encode a number.
var detector = new FLARMultiIdMarkerDetector(param, 120);

// For tracking video set continue mode to true. In continue mode, the detector
// tracks markers across multiple frames.
detector.setContinueMode(true);

// Copy the camera perspective matrix from the FLARParam to the WebGL library camera matrix.
// The second and third parameters determine the zNear and zFar planes for the perspective matrix.
param.copyCameraMatrix(display.camera.perspectiveMatrix, 10, 10000);
</pre>


<h2 id="toc-webrtc">Using WebRTC to access the webcam</h2>

<p>Next, I'm going to create a video element that's getting webcam video through WebRTC. For pre-recorded videos, just set the source attribute of the video to the video URL. If you're doing marker detection from still images, you can use a image element in much the same way.

<pre class="prettyprint">
var video = document.createElement('video');
video.width = 320;
video.height = 240;
navigator.webkitGetUserMedia('video',
  function(stream) {
    var url = webkitURL.createObjectURL(stream);
    video.src = url;
  },
  function(error) {
    alert('No WebRTC webcam found.');
  }
);
</pre>

<h2 id="toc-detecting">Detecting markers</h2>

<p>Once we have the detector running a-ok, we can start feeding it images to detect AR matrices. First draw the image onto the raster object canvas, then run the detector on the raster object. The detector returns the number of markers found in the image.

<pre class="prettyprint">
// Draw the video frame to the raster canvas, scaled to 320x240.
canvas.getContext('2d').drawImage(video, 0,0,320,240);

// Do marker detection by using the detector object on the raster object.
// The threshold parameter determines the threshold value
// for turning the video frame into a 1-bit black-and-white image.
//
var markerCount = detector.detectMarkerLite(raster, threshold);
</pre>


<p>The last step is to iterate through the detected markers and get their transformation matrices. You use the transformation matrices for putting 3D objects on top of the markers.

<pre class="prettyprint">
// Create a NyARTransMatResult object for getting the marker translation matrices.
var resultMat = new NyARTransMatResult();

var markers = {};

// Go through the detected markers and get their IDs and transformation matrices.
for (var idx = 0; idx &lt; markerCount; idx++) {
  // Get the ID marker data for the current marker.
  // ID markers are special kind of markers that encode a number.
  // The bytes for the number are in the ID marker data.
  var id = detector.getIdMarkerData(idx);

  // Read bytes from the id packet.
  var currId = -1;
  // This code handles only 32-bit numbers or shorter.
  if (id.packetLength <= 4) {
    currId = 0;
    for (var i = 0; i &lt; id.packetLength; i++) {
      currId = (currId << 8) | id.getPacketData(i);
    }
  }

  // If this is a new id, let's start tracking it.
  if (markers[currId] == null) {
    markers[currId] = {};
  }
  // Get the transformation matrix for the detected marker.
  detector.getTransformMatrix(idx, resultMat);

  // Copy the result matrix into the marker object.
  markers[currId].transform = Object.asCopy(resultMat);
}
</pre>


<h2 id="toc-matrixmapping">Matrix mapping</h2>

<p>Here's the code to copy JSARToolKit matrices over to glMatrix matrices (which are 16-element FloatArrays with the translation column in the last four elements). It works by magic (read: I don't know how ARToolKit matrices are setup). Inverted Y-axis is my guess. Anyway, this bit of sign-reversing voodoo makes a JSARToolKit matrix work the same as a glMatrix.

<p>To use the library with another library, such as Three.js, you need to write a function that converts the ARToolKit matrices to the library's matrix format. You also need to hook into the FLARParam.copyCameraMatrix method. The copyCameraMatrix method writes the FLARParam perspective matrix into a glMatrix-style matrix.

<pre class="prettyprint">
function copyMarkerMatrix(arMat, glMat) {
  glMat[0] = arMat.m00;
  glMat[1] = -arMat.m10;
  glMat[2] = arMat.m20;
  glMat[3] = 0;
  glMat[4] = arMat.m01;
  glMat[5] = -arMat.m11;
  glMat[6] = arMat.m21;
  glMat[7] = 0;
  glMat[8] = -arMat.m02;
  glMat[9] = arMat.m12;
  glMat[10] = -arMat.m22;
  glMat[11] = 0;
  glMat[12] = arMat.m03;
  glMat[13] = -arMat.m13;
  glMat[14] = arMat.m23;
  glMat[15] = 1;
}
</pre>


<h2 id="toc-summary">Summary</h2>

<p>In this article we went through the basics of JSARToolKit. Now you are ready to build your own webcam-using augmented reality applications with JavaScript. 


  <h2 id="toc-references">References</h2>
  <ul>
    <li><a href="https://github.com/kig/JSARToolKit/">JSARToolKit</a></li>
    <li><a href="https://github.com/mrdoob/three.js/">Three.js</a></li>
  </ul>

{% endblock %}
