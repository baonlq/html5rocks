{% extends "sample.html" %}

{% block headauthor %}Boris Smus{% endblock %}
{% block pageauthor %}{% profilelinks smus %}{% endblock %}
{% block headtitle %}Introduction to the Web Audio API{% endblock %}
{% block pagetitle %}Introduction to the Web Audio API{% endblock %}
{% block pagebreadcrumb %}Introduction to the Web Audio API{% endblock %}
{% block date %}October 11, 2011{% endblock %}

{% block head %}
<style>
  iframe { width: 100%; height: 340px; border: 0; overflow: hidden; }
</style>
{% endblock %}

{% block browsersupport %}
<span class="opera"></span>
<span class="ie"></span>
<span class="safari supported"></span>
<span class="ff"></span>
<span class="chrome supported"></span>
{% endblock %}

{% block iscompatible %}
  return !!Modernizr.canvas
{% endblock %}

{% block html5badge %}
<img src="/static/images/identity/html5-badge-h-multimedia.png" width="133" height="64" alt="This article is powered by HTML5 Graphics, 3D &amp; Effects" title="This article is powered by HTML5 Graphics, 3D &amp; Effects" />
{% endblock %}

{% block content %}

<p>Before the HTML5 <code>&lt;audio&gt;</code> element, flash or another plugin was required
to break the silence of the web. While the audio tag no longer requires a
plugin, it brings significant limitations for implementing sophisticated
games and interactive applications.</p>
<p>The Web Audio API is a high-level JavaScript API for processing and
synthesizing audio in web applications. The goal of this API is to
include capabilities found in modern game audio engines as well as some
of the mixing, processing, and filtering tasks that are found in modern
desktop audio production applications.</p>
<p>As of version 14, Google Chrome ships with a Web Audio API
implementation. More recently, the Safari WebKit nightly build also
supports it. What follows is a gentle introduction to using this
powerful API.</p>
<h2 id="toc-context">The AudioContext</h2>

<p>An <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioContext-section">AudioContext</a> is used for managing and playing all sounds. In most cases a
single AudioContext is created per page.</p>
<p>To produce a sound using the Web Audio API, you create one or more sound
sources and connect them to the sound destination provided by the AudioContext.
This connection doesn't need to be direct, and can instead go through
any number of intermediate <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioNode-section">AudioNodes</a>. This <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#ModularRouting-section">routing</a> is described in
greater detail at the Web Audio <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html">specification</a>.</p>
<p>The following snippet creates an <code>AudioContext</code>:</p>
<pre class="prettyprint"><code>var context;
window.addEventListener('load', init, false);
function init() {
  try {
    context = new webkitAudioContext();
  }
  catch(e) {
    alert('Web Audio API is not supported in this browser');
  }
}
</code></pre>
<p>One thing to note in the above snippet is that for the WebKit
implementation, the <code>'webkit'</code> prefix is used when creating the
<code>AudioContext</code>. Also, we should be careful not to try to execute Web Audio
code on a browser that doesn't support it.</p>
<p>Many of the interesting Web Audio API functionality such as creating
AudioNodes and decoding audio file data are methods of the <code>AudioContext</code>.</p>
<h2 id="toc-load">Loading sounds</h2>

<p>The Web Audio API uses an AudioBuffer for short to medium length sounds.
The basic approach is to use <code>XMLHttpRequest</code> for fetching sound files.</p>
<p>The API supports loading audio file data in multiple formats, such as WAV, MP3,
AAC, or OGG. Please note that browser support for the different formats varies.
The following snippet demonstrates loading a sound sample:</p>
<pre class="prettyprint"><code>var dogBarkingBuffer = null;
var context = new webkitAudioContext();

function loadDogSound(url) {
  var request = new XMLHttpRequest();
  request.open('GET', url, true);
  request.responseType = 'arraybuffer';

  // Decode asynchronously
  request.onload = function() {
    context.decodeAudioData(request.response, function(buffer) {
      dogBarkingBuffer = buffer;
    }, onError);
  }
  request.send();
}
</code></pre>
<p>The audio file data is binary (not text) so we set the <code>responseType</code> of the
request to <code>'arraybuffer'</code>. For more information about <code>ArrayBuffers</code>,
see this <a href="http://www.html5rocks.com/en/tutorials/file/xhr2/">article about XHR2</a>.</p>
<p>Once the (undecoded) audio file data has been received, it can be kept around
for later decoding, or more normally, it can be decoded right away using the
AudioContext <code>decodeAudioData()</code> method. This method takes the <code>ArrayBuffer</code> of
audio file data stored in <code>request.response</code> and decodes it asynchronously (not
blocking the main JavaScript execution).</p>
<p>When <code>decodeAudioData()</code> is finished it calls a callback function which
provides the decoded PCM audio data as an <code>AudioBuffer</code>.</p>
<h2 id="toc-play">Playing sounds</h2>

<p><figure>
<img alt="simple-graph" src="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/modular-routing1.png" />
<figcaption>A simple audio graph</figcaption>
</figure></p>
<p>Once one or more <code>AudioBuffers</code> are loaded then we're ready to play sounds. Let's
assume we've just loaded an <code>AudioBuffer</code> with the sound of a dog barking and
that the loading has finished.</p>
<p>Then we can play this buffer with a the following code.</p>
<pre class="prettyprint"><code>var context = new webkitAudioContext();

function playSound(buffer) {
  var source = context.createBufferSource(); // creates a sound source
  source.buffer = buffer;                    // tell the source which sound to play
  source.connect(context.destination);       // connect the source to the context's destination (the speakers)
  source.noteOn(0);                          // play the source now
}
</code></pre>
<p>This <code>playSound()</code> function could be called every time somebody presses a key or
clicks something with the mouse.</p>
<p>Note that the <code>noteOn(time)</code> function makes it easy to schedule precise sound
playback for games and other time-critical applications. However, to get
this scheduling working properly, ensure that your sound buffers are
pre-loaded.</p>
<h2 id="toc-abstract">Abstracting the Web Audio API</h2>

<p>Of course, it would be better to create a more general loading system which
isn't hard-coded to loading this specific sound. There are many approaches for
dealing with the many short to medium length sounds that an audio application
or game would use - here's one way using a <a href="js/buffer-loader.js">BufferLoader class</a>.</p>
<p>Here's how the <code>BufferLoader</code> class can be used. In this simple example, two
<code>AudioBuffers</code> are created and when they are finished loading, they are played
back at the same time.</p>
<pre class="prettyprint"><code>window.onload = init;
var context;
var bufferLoader;

function init() {
  context = new webkitAudioContext();

  bufferLoader = new BufferLoader(
    context,
    [
      '../sounds/hyper-reality/br-jam-loop.wav',
      '../sounds/hyper-reality/laughter.wav',
    ],
    finishedLoading
    );

  bufferLoader.load();
}

function finishedLoading(bufferList) {
  // Create two sources and play them both together.
  var source1 = context.createBufferSource();
  var source2 = context.createBufferSource();
  source1.buffer = bufferList[0];
  source2.buffer = bufferList[1];

  source1.connect(context.destination);
  source2.connect(context.destination);
  source1.noteOn(0);
  source2.noteOn(0);
}
</code></pre>
<h2 id="toc-abstract">Dealing with time: playing sounds with rhythm</h2>

<p>The Web Audio API lets developers precisely schedule playback. To
demonstrate this, let's setup a simple rhythm track. Probably the
most widely known drumkit pattern is the following:</p>
<p><figure>
<img alt="drumkit" src="diagrams/drum.png" />
<figcaption>A simple rock drum pattern</figcaption>
</figure></p>
<p>in which a hihat is played every eight note, and kick and snare are
played alternating every quarter, in 4/4 time.</p>
<p>Supposing we have loaded the <code>kick</code>, <code>snare</code> and <code>hihat</code> buffers, the
code to do this is simple:</p>
<pre class="prettyprint"><code>for (var bar = 0; bar &lt; 2; bar++) {
  var time = startTime + bar * 8 * eighthNoteTime;
  // Play the bass (kick) drum on beats 1, 5
  playSound(kick, time);
  playSound(kick, time + 4 * eighthNoteTime);

  // Play the snare drum on beats 3, 7
  playSound(snare, time + 2 * eighthNoteTime);
  playSound(snare, time + 6 * eighthNoteTime);

  // Play the hi-hat every eighth note.
  for (var i = 0; i &lt; 8; ++i) {
    playSound(hihat, time + i * eighthNoteTime);
  }
}
</code></pre>
<p>Here, we make only one repeat instead of the unlimited loop we see in
the sheet music. The function <code>playSound</code> is a method that plays a
buffer at a specified time, as follows:</p>
<pre class="prettyprint"><code>function playSound(buffer, time) {
  var source = context.createBufferSource();
  source.buffer = buffer;
  source.connect(context.destination);
  source.noteOn(time);
}
</code></pre>
<input type="button" onclick="RhythmSample.play();" value="Play"/>

<p><a href="js/rhythm-sample.js">full source code</a></p>
<h2 id="toc-volume">Changing the volume of a sound</h2>

<p>One of the most basic operations you might want to do to a sound is
change its volume. Using the Web Audio API, we can route our source to
its destination through an <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioGainNode-section">AudioGainNode</a> in order to manipulate the
volume:</p>
<p><figure>
<img alt="gain-graph" src="diagrams/gain.png" />
<figcaption>Audio graph with a gain node</figcaption>
</figure></p>
<p>This connection setup can be achieved as follows:</p>
<pre class="prettyprint"><code>// Create a gain node.
var gainNode = context.createGainNode();
// Connect the source to the gain node.
source.connect(gainNode);
// Connect the gain node to the destination.
gainNode.connect(context.destination);
</code></pre>
<p>After the graph has been set up, you can programmatically change the
volume by manipulating the <code>gainNode.gain.value</code> as follows:</p>
<pre class="prettyprint"><code>// Reduce the volume.
gainNode.gain.value = 0.5;
</code></pre>
<p>The following is a demo of a volume control implemented with an <code>&lt;input
type="range"&gt;</code> element:</p>
<p><input type="button" onclick="VolumeSample.toggle();" value="Play/Pause"/>
Volume: <input type="range" min="0" max="100" value="100" onchange="VolumeSample.changeVolume(this);" /></p>
<p><a href="js/volume-sample.js">full source code</a></p>
<h2 id="toc-xfade">Cross-fading between two sounds</h2>

<p>Now, suppose we have a slightly more complex scenario, where we're
playing multiple sounds, but want to cross fade between them. This is a
common case in a DJ-like application, where we have two turntables and
want to be able to pan from one sound source to another.</p>
<p>This can be done with the following audio graph:</p>
<p><figure>
<img alt="crossfade-graph" src="diagrams/crossfade.png" />
<figcaption>Audio graph with two sources connected through gain nodes</figcaption>
</figure></p>
<p>To set this up, we simply create two <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioGainNode-section">AudioGainNodes</a>, and connect
each source through the nodes, using something like this function:</p>
<pre class="prettyprint"><code>function createSource(buffer) {
  var source = context.createBufferSource();
  // Create a gain node.
  var gainNode = context.createGainNode();
  source.buffer = buffer;
  // Turn on looping.
  source.loop = true;
  // Connect source to gain.
  source.connect(gainNode);
  // Connect gain to destination.
  gainNode.connect(context.destination);

  return {
    source: source,
    gainNode: gainNode
  };
}
</code></pre>
<h3 id="toc-xfade-ep">Equal power crossfading</h3>

<p>Note that a naive linear crossfade approach will exhibit a volume dip as
you pan between the samples.</p>
<p><figure>
<img alt="linear-crossfade-graph" src="diagrams/linear-fade.png" />
<figcaption>A linear crossfade</figcaption>
</figure></p>
<p>To address this issue, we use an equal power curve, in which the
corresponding gain curves are non-linear, and intersect at a higher
amplitude. This minimizes volume dips between audio regions, resulting
in a more even crossfade between regions that may be slightly different
in level.</p>
<p><figure>
<img alt="equalpower-crossfade-graph" src="diagrams/equal-fade.png" />
<figcaption>An equal power crossfade</figcaption>
</figure></p>
<p>The following demo uses an <code>&lt;input type="range"&gt;</code> control to crossfade
between the two sound sources:</p>
<p><input type="button" onclick="CrossfadeSample.toggle();" value="Play/Pause"/>
Drums <input type="range" min="0" max="100" value="100" onchange="CrossfadeSample.crossfade(this);" /> Organ</p>
<p><a href="js/crossfade-sample.js">full source code</a></p>
<h3 id="toc-xfade-play">Playlist crossfading</h3>

<p>Another common crossfader application is for a music player application.
When a song changes, we want to fade the current track out, and fade the
new one in, to avoid a jarring transition. To do this, we need to
schedule a crossfade into the future. While we could use <code>setTimeout</code> to
do this scheduling, this is <a href="http://stackoverflow.com/questions/2779154/understanding-javascript-timer-thread-issues">quite inaccurate</a>. With the Web
Audio API, we can use the <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioParam-section">AudioParam</a> interface to schedule future
values for parameters such as the gain value of an <code>AudioGainNode</code>.</p>
<p>Thus, given a playlist, we can transition between tracks by scheduling a
gain decrease on the currently playing track, and a gain increase on the
next one, both slightly before the current track finishes playing:</p>
<pre class="prettyprint"><code>function playHelper(bufferNow, bufferLater) {
  var playNow = createSource(bufferNow);
  var source = playNow.source;
  var gainNode = playNow.gainNode;
  var duration = bufferNow.duration;
  var currTime = context.currentTime;
  // Fade the playNow track in.
  gainNode.gain.linearRampToValueAtTime(0, currTime);
  gainNode.gain.linearRampToValueAtTime(1, currTime + ctx.FADE_TIME);
  // Play the playNow track.
  source.noteOn(0);
  // At the end of the track, fade it out.
  gainNode.gain.linearRampToValueAtTime(1, currTime + duration-ctx.FADE_TIME);
  gainNode.gain.linearRampToValueAtTime(0, currTime + duration);
  // Schedule a recursive track change with the tracks swapped.
  var recurse = arguments.callee;
  ctx.timer = setTimeout(function() {
    recurse(bufferLater, bufferNow);
  }, (duration - ctx.FADE_TIME) * 1000);
}
</code></pre>
<p>The Web Audio API provides a convenient set of <code>RampToValue</code> methods to
gradually change the value of a parameter, such as
<code>linearRampToValueAtTime</code> and <code>exponentialRampToValueAtTime</code>.</p>
<p>While the transition timing function can be picked from built-in linear
and exponential ones (as above), you can also specify your own value
curve via an array of values using the <code>setValueCurveAtTime</code> function.</p>
<p>The following demo shows an playlist-like auto-crossfade between two
tracks using the above approach:</p>
<input type="button" onclick="CrossfadePlaylistSample.toggle();" value="Play/Pause"/>

<p><a href="js/crossfade-playlist-sample.js">full source code</a></p>
<h2 id="toc-filter">Applying a simple filter effect to a sound</h2>

<p><figure>
<img alt="filter-graph" src="diagrams/filter.png" />
<figcaption>An audio graph with a <code>BiquadFilterNode</code></figcaption>
</figure></p>
<p>The Web Audio API lets you pipe sound from one audio node into another,
creating a potentially complex chain of processors to add complex
effects to your soundforms.</p>
<p>One way to do this is to place <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#BiquadFilterNode-section">BiquadFilterNode</a>s between your sound
source and destination. This type of audio node can do a variety of
low-order filters which can be used to build graphic equalizers and even
more complex effects, mostly to do with selecting which parts of the
frequency spectrum of a sound to emphasize and which to subdue.</p>
<p>Supported types of filters include:</p>
<ul>
<li>Low pass filter</li>
<li>High pass filter</li>
<li>Band pass filter</li>
<li>Low shelf filter</li>
<li>High shelf filter</li>
<li>Peaking filter</li>
<li>Notch filter</li>
<li>All pass filter</li>
</ul>
<p>And all of the filters include parameters to specify some amount of
gain, the frequency at which to apply the filter, and a quality factor.
The low-pass filter keeps the lower frequency range, but discards high
frequencies. The breakoff point is determined by the frequency value,
and the Q factor is unitless, and determines the shape of the graph. The
gain only affects certain filters, such as the low-shelf and peaking
filters, and not this low-pass filter.</p>
<p>Let's setup a simple low-pass filter to extract only the bases from a
sound sample:</p>
<pre class="prettyprint"><code>// Create the filter
var filter = context.createBiquadFilter();
// Create the audio graph.
source.connect(filter);
filter.connect(context.destination);
// Create and specify parameters for the low-pass filter.
filter.type = 0; // Low-pass filter. See BiquadFilterNode docs
filter.frequency.value = 440; // Set cutoff to 440 HZ
// Playback the sound.
source.noteOn(0);
</code></pre>
<p>The following demo uses a similar technique and lets you enable and
disable a lowpass filter via a checkbox, as well as tweak the frequency
and quality values with the slider:</p>
<p><input type="button" onclick="FilterSample.toggle();" value="Play/Pause"/>
Filter on: <input type="checkbox" checked="false"
    onchange="FilterSample.toggleFilter(this);"/>
Frequency: <input type="range" min="0" max="1" step="0.01" value="1" onchange="FilterSample.changeFrequency(this);" />
Quality: <input type="range" min="0" max="1" step="0.01" value="0" onchange="FilterSample.changeQuality(this);" /></p>
<p><a href="js/filter-sample.js">full source code</a></p>
<p>In general, frequency controls need to be tweaked to work on a
logarithmic scale since human hearing itself works on the same principle
(ie. A4 is 440hz, and A5 is 880hz). For more details, see the
<code>FilterSample.changeFrequency</code> function in the source code link above.</p>
<p>Lastly, note that the sample code lets you connect and disconnect the
filter, dynamically changing the AudioContext graph. We can disconnect
AudioNodes from the graph by calling <code>node.disconnect(outputNumber)</code>.
For example, to re-route the graph from going through a filter, to a
direct connection, we can do the following:</p>
<pre class="prettyprint"><code>// Disconnect the source and filter.
source.disconnect(0);
filter.disconnect(0);
// Connect the source directly.
source.connect(context.destination);
</code></pre>
<h2 id="toc-further">Further listening</h2>

<p>We've covered the basics of the API, including loading and playing audio
samples. We've built audio graphs with gain nodes and filters and
scheduled sounds and audio parameter tweaks to enable some common sound
effects. At this point you are ready to go and build some sweet web
audio applications!</p>
<p>If you are seeking inspiration, many developers have already created
<a href="http://chromium.googlecode.com/svn/trunk/samples/audio/samples.html">great work</a> using the Web Audio API. Some of my favorite
include:</p>
<ul>
<li><a href="http://audiojedit.herokuapp.com/">AudioJedit</a>, an in-browser sound splicing tool that uses
  SoundCloud permalinks.</li>
<li><a href="http://labs.dinahmoe.com/ToneCraft/">ToneCraft</a>, a sound sequencer where sounds are created by
  stacking 3D blocks.</li>
<li><a href="http://labs.dinahmoe.com/plink/">Plink</a>, a collaborative music making game using Web Audio and Web
  Sockets.</li>
</ul>  <script src="js/buffer-loader.js"></script>
  <script src="js/volume-sample.js"></script>
  <script src="js/rhythm-sample.js"></script>
  <script src="js/crossfade-sample.js"></script>
  <script src="js/crossfade-playlist-sample.js"></script>
  <script src="js/filter-sample.js"></script>
  <script src="js/init.js"></script>
{% endblock %}
