{% extends "../../../../templates/sample.html" %}

{% block headauthor %}Malte Ubl <malte.ubl@google.com>{% endblock %}
{% block pageauthor %}Malte Ubl{% endblock %}
{% block headtitle %}The Basics of Web Sockets{% endblock %}
{% block pagetitle %}The Basics of Web Sockets{% endblock %}
{% block pagebreadcrumb %}The Basics of Web Sockets{% endblock %}
{% block head %}
{% endblock %}
{% block date %}October 20, 2010{% endblock %}

{% block browsersupport %}
<span class="opera supported"></span>
<span class="safari supported"></span>
<span class="ff supported"></span>
<span class="chrome supported"></span>
{% endblock %}

{% block iscompatible %}
  return Modernizr.websockets;
{% endblock %}

{% block content %}
  <h2 id="toc-introduction-lowlatency">The Problem: Low Latency Client-Server and Server-Client Connections</h2>
  <p>The web has been largely built around the so called request response paradigm of HTTP. A client loads up a web page
  and then nothing happens until the user clicks onto the next page. Around the year 2005 Ajax appeared to make the 
  web more dynamic. But still all communication was steered by the client which was periodically or upon user interaction
  loading new data from the server using HTTP requests.</p>

  <p>Technologies that enable the server to send data to the client in the very moment when it knows that
  new data is available have been around for quite some time. They go by names such as Push or Comet. One of the most 
  common hacks to create the illusion of server initiated connections is so called long polling. With long polling
  the client opens a HTTP connection to the server which then keeps it "hanging". Whenever the server actually has new
  data it takes that HTTP request and sends the response (other techniques involve Flash, XHR multipart requests and so
  called htmlfiles). Long polling and the other techniques work quite well and you probably use them every day in 
  application such as the G-Mail chat.</p>

  <p>However, all the work arounds share one problem: They still carry the overhead of HTTP which makes them not well
  suited when you need really low latency. Think multi player first person shooter games in the browser or really any other online game with a true multi player component.</p>

  <h2 id="toc-introduction-sockets">Introducing Web Sockets: Bringing Sockets to the Web</h2>

  <p>The <a href="http://dev.w3.org/html5/websockets/">WebSockets</a> specification defines
  an API establishing "socket" connections between a web browser and a server. In plain words this means:
  There is an open connection between the client and the server and both parties can start sending data
  at any time.</p>
  
  <p>WebSockets use a message-passing API which might feel familiar if you have worked with Web Workers in the past.</p>

  <h2 id="toc-gettingstarted">Getting Started</h2>

  <p>You open up a web socket connection simply by calling the WebSocket constructor:</p>

  <pre class="prettyprint">
var connection = new WebSocket("ws://websockets.org:8787/echo");
</pre>

  <p>It also makes sense to immediately attach some event handlers to the connection so that we know
  when the connection is open, we get informed about incoming messages and we know when there is an error.</p>
  
  <pre class="prettyprint">
var connection = new WebSocket("ws://websockets.org:8787/echo");

// When the connection is open, send some data to the server
connection.onopen = function () {
  connection.send("Ping"); // Send the message 'Ping' to the server
}

// Log errors
connection.onerror = function (error) {
  console.log("WebSocket Error " + error);
};

// Log messages from the server
connection.onmessage = function (e) {
  console.log("Server: " + e.data);
}
</pre>

  <h3 id="toc-gettingstarted-workercomm">Communicating with the Server</h3>

  <p>There is really not much too it. As soon as we have a connection to the server (when <code>onopen</code> fired)
  we can starte sending data to the server using the <code>send('your message')</code> method on the connection
  object. Equally the server might send us messages at any time. Whenever this happens the <code>onmessage</code> callback
  fires. The callback receives an event object and the actual message is accessible via the <code>data</code>
  property.</p>

  <h2 id="toc-cross">Cross Origin Communication</h2>

  <p>Being a modern protocol cross origin communication is baked right into WebSockets. While you should
  still make sure only to communicate with clients and server that you trust, WebSockets enable communication
  between parties on any domain. The server gets to decide to make it's service available to all clients or
  only to those that reside on a set of well defined domains.</p>

  <h2 id="toc-usecases">Proxy Servers</h2>

  <p>Every new technology comes with a new set of problems. In the case of WebSockets it is the compatibility
  with so called proxy servers which mediate HTTP connections in most company networks. The WebSocket protocol uses the
  HTTP upgrade system (which is normally used for HTTPS/SSL) to "upgrade" a HTTP connection to a WebSocket
  connection. Some proxy server do not like this and will drop the connection. Thus even if a given client
  might implement the WebSocket spec it might not be possible to actually open a connection. This makes the next
  paragraph even more important :)</p>

  <h2 id="toc-usecases">Use WebSockets Today</h2>
  
  <p>While WebSockets are very recent technology and there is still active work on the actual wire protocol
  format you can use WebSockets today with libraries that use one of the fallbacks mentioned above whenever
  WebSockets are not available. A library that has become very popular in this domain is 
  <a href="http://socket.io/">socket.io</a> which comes with a client and a server implementation of the protocol
  and all the fallbacks.</p>
  
  <h2 id="toc-usecases">Use Cases</h2>

  <p>Use WebSockets whenever you need a truly low latency connection between the client and the server. Keep in
  mind that this might involve rethinking how you build your server side applications with a new focus on
  technologies such as event queues:</p>
  
  <ul>
    <li>Multiplayer online games</li>
    <li>Chat applications</li>
    <li>Live sports ticker</li>
    <li>Live updating social streams</li>
    <li>...</li>
  </ul>

  <h2 id="toc-examples">Demos</h2>
  <ul>
    <li>...</li>
  </ul>

  <h2 id="toc-references">References</h2>
  <ul>
    <li>...</li>
  </ul>
{% endblock %}
