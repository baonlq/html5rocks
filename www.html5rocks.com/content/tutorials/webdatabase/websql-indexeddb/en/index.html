{% extends "sample.html" %}

{% block headauthor %}Ido Green <idog@google.com>{% endblock %}
  {% block pageauthor %}{% profilelinks idogreen %}{% endblock %}
  {% block headtitle %}Migrating your WebSQL DB to IndexedDB{% endblock %}
  {% block pagetitle %}Migrating your WebSQL DB to IndexedDB{% endblock %}
  {% block head %}

  {% endblock %}
  {% block pagebreadcrumb %}Migrating your WebSQL DB to IndexedDB{% endblock %}
  {% block date %}December 05, 2011{% endblock %}
  {% block updated %}{% endblock %}
  {% block onload %}{% endblock %}

  {% block browsersupport %}
  <span class="opera"></span>
  <span class="ie"></span>
  <span class="safari"></span>
  <span class="ff supported"></span>
  <span class="chrome supported"></span>
  {% endblock %}

  {% block iscompatible %}
  return typeof window.openDatabase == "function" ? true : false;
  {% endblock %}

  {% block content %}



  <h2 id="toc-introduction">Introduction</h2>

  <p>Web Databases are hosted and persisted inside a user's browser. By allowing developers to create
    applications with rich query abilities it is envisioned that a new breed of web applications will
    emerge that have the ability to work online and offline in cases where you don’t have connection
    (or flaky network).
  </p>
  <p>Since November 18, 2010, the W3C announced that Web SQL database is a deprecated specification. 
    This is a recommendation for web developers to no longer use the technology as effectively the spec
    will receive no new updates and browser vendors aren't encouraged to support this technology. 
    The new alternative is IndexedDB and currently you can work with it on Chrome 12+ and Firefox 5+.
    In the future we will have it on IE10 as well.
  </p>
  <p>
    In this tutorial we will take the simple example of a todo list and see how we could ‘move’ our 
    WebSQL code to indexedDB one. 
  </p>

  <h2 id="toc-topic">Initializing the database</h2>

  <p>In the majority of cases where you are using Web Database support you will be using the Asynchronous API.
    The Asynchronous API is a non-blocking system and as such will not get data through return values, 
    but rather will get data delivered to a defined callback function. We are going to use it in both cases
    (webSQL and indexedDB). Let’s see how we creating the database in each case.
  </p>
  <h3 id="toc-topic-subtopic">WebSQL - Creating the database</h3>
  <p>You can only create a table by executing a CREATE TABLE SQL statement inside a transaction. 
    We have defined a function that will create a table in the body onload event. If the table doesn't 
    already exist, a table will be created. In our case, let’s have 2MB of memory allocated to our todo list, 
    enough is enough, no?
  </p>
  <pre class="prettyprint">
    var db = openDatabase('todos1', '1.0', 'todo list example db', 2*1024*1024);
  </pre>

  <h3 id="toc-topic-subtopic">IndexedDB - Creating the database</h3>
  <p>In indexedDB we will need more code because we wish to avoid the prefix (webkit, moz etc’) in order to 
    have cleaner code. Moreover, when more browsers will implement this feature we could use the window 
    object without any prefix so our code is ‘ready’ for that.
  </p>
  <pre class="prettyprint">  
    var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;

    indexedDB.db = null;
    // hook up the errors to the console so we could see it. In the future, we need to push these messages to the user.
    indexedDB.onerror = function(e) {
    console.log(e);
    };
  </pre>

  <h3 id="toc-topic-subtopic">Create a table</h3>

  <p>Now in webSQL we will want to create a table. This is the code that will define it for us:</p>
  <pre class="prettyprint">  
    if (database) {
       database.transaction(function(tx) {
         tx.executeSql("CREATE TABLE IF NOT EXISTS tasks (id REAL UNIQUE, text TEXT)", []);
       });
    }
  </pre>

  <p>while in indexedDB we will create an object store inside a ‘SetVersion’ transaction. 
    SetVersion is the only place in our code that we can alter the structure of the database. 
    In it we can create and delete Object Stores and build and remove indexes. A call to setVersion 
    returns an IDBRequest object where we can attach our callbacks. When successful, we start to create 
    our Object Stores.
  </p>
  <pre class="prettyprint">  
indexedDB.open = function() {
        var request = indexedDB.open("todos");


        request.onsuccess = function(e) {
          var v = "2.0 beta"; // yes! you can put strings in the version not just numbers
          todoDB.indexedDB.db = e.target.result;
          var db = todoDB.indexedDB.db;
          // We can only create Object stores in a setVersion transaction;
          if (v!= db.version) {
            var setVrequest = db.setVersion(v);


            // onsuccess is the only place we can create Object Stores
            setVrequest.onfailure = todoDB.indexedDB.onerror;
            setVrequest.onsuccess = function(e) {
              if(db.objectStoreNames.contains("todo")) {
                db.deleteObjectStore("todo");
              }


              var store = db.createObjectStore("todo",{keyPath: "timeStamp"});


              todoDB.indexedDB.getAllTodoItems();
            };
          }
          else {
            todoDB.indexedDB.getAllTodoItems();
          }
        };


        request.onfailure = todoDB.indexedDB.onerror;
      }
  </pre>

  <p>Object Stores are created with a single call to createObjectStore. The method takes a name of the store, 
    and an parameter object. The parameter object is very important, it lets you define important optional 
    properties. In our case, we define a keyPath that is the property that makes an individual object in the 
    store unique. That property in this example is "timeStamp". "timeStamp" must be present on every object that 
    is stored in the objectStore.
  </p>
  <p>
    <b>(!)</b> Please note that according to latest IndexedDB spec (as of 12/5/2011): 
    <a href="http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html" target="_blank">dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html</a>
    setVersion() will be taken out. Thus, our code snippets here is going to change and the version setting will
    be part of the open() function of the database.
  </p>


  <h3 id="toc-topic-subtopic">Adding data</h3>
  <p>
    Let’s have a look at the most basic ability - adding data to our database. In both cases, we are using 
    the location (table or objectStore) and then adding some data into it.
  </p>

  <h4>WebSQL - Adding item</h4>
  <pre class="prettyprint">  
    function addTodo() {
        var todo = document.getElementById("todo");
        var task = {
          "id": new Date().getTime(),
          "text": todo.value };
        
        database.transaction(function(tx) {
          tx.executeSql('INSERT INTO tasks (id, text) values (?, ?)', [task.id, task.text]);
        });
        // now let clean it to the next todo
        todo.value = "";
        showAll();
      }
  </pre>

  <h4>IndexedDB - Adding item</h4>
  <p>We first get a quick reference to the database object todoDB.indexedDB.db, initiate a READ_WRITE 
    transaction and get a reference to our object store. Now that the application has access to the Object
    Store, we can issue a simple put command with a basic JSON object. Notice that there is a timeStamp 
    property, that is our unique key for the object and is used as the "keyPath". When the call to put is 
    successful, our onsuccess event is triggered and we are able to render the contents to the screen.
  </p>

  <pre class="prettyprint">  
    indexedDB.addTodo = function() {
        var db = todoDB.indexedDB.db;
        var trans = db.transaction(['todo'], IDBTransaction.READ_WRITE);
        var store = trans.objectStore('todo');


        var data = {
          "text": todoText, // todoText should be visible here
          "timeStamp": new Date().getTime()
        };


        var request = store.put(data);


        request.onsuccess = function(e) {
          todoDB.indexedDB.getAllTodoItems();
        };


        request.onerror = function(e) {
          console.log("Error Adding: ", e);
        };
      };
  </pre>


  <h3 id="toc-topic-subtopic">Fetching data</h3>
  <p>After we put ‘huge’ amount of data in our database we wish to get it out. In webSQL we will use the 
    familiar syntax of ‘Select’.
  </p>

  <h4>WebSQL - fetching data</h4>
  <pre class="prettyprint">  
function showAll() {
        document.getElementById("ourList").innerHTML = "" ;
        database.transaction(function(tx) {
          tx.executeSql('SELECT * FROM tasks', [], function (tx, results) {
            var len = results.rows.length;
            for (var i = 0; i < len; i++) {
              var li = document.createElement("li");
              var t = document.createTextNode(i+ ") key: " + results.rows.item(i).id +
                " => Todo text: " + results.rows.item(i).text);
              // have the ability to delete the item using data attributes and a link.
              var a = document.createElement("a");
              a.textContent = " [Delete]";
              a.dataset.key   = results.rows.item(i).id;
              a.dataset.value = results.rows.item(i).text;
              a.addEventListener("click", function() {
                deleteTodo(this.dataset.key, this.dataset.val );
              }, false);
              li.appendChild(t);
              li.appendChild(a);
              document.getElementById("ourList").appendChild(li);
            }
          });       
        });
      }
  </pre>

  <h4>IndexedDB - fetching data</h4>
  <p>We open a transaction on our object store. This is set to READ_ONLY because we only wish to retrieve data. 
    Next, we opening a cursor and iterate with it on our list of Todos. All of these commands used in this sample 
    are asynchronous and as such the data is not returned from inside the transaction.
  </p>

  <pre class="prettyprint">  

    function showAll() {
        document.getElementById("ourList").innerHTML = "" ;  
        var request = window.indexedDB.open("todos");
        request.onsuccess = function(event) {
          // Enumerate the entire object store.
          var db = todoDB.indexedDB.db;
          var trans = db.transaction(["todo"], IDBTransaction.READ_ONLY);
          var request = trans.objectStore("todo").openCursor();
  
          request.onsuccess = function(event) {
            // This hack is to allow our code to run with Firefox (older versions then 6)
            var cursor = request.result || event.result;             
           // If cursor is null then we've completed the enumeration.
            if (!cursor) {
              return;
            }
            var element = document.createElement("div");
            element.textContent = "key: " + cursor.key + " => Todo text: " + cursor.value.text;
            document.getElementById("ourList").appendChild(element);
            cursor.continue();
          }
        }                   
      }
  </pre>





  <h3 id="toc-topic-subtopic">Deleting data</h3>

  <h4>WebSQL - delete data</h4>
  <p>We use a simple SQL to delete a todo item base on its id. We took the extra mile here, and we even, 
    warn the user. That’s how we like to roll...
  </p>

  <pre class="prettyprint">  
    function deleteTodo(id, text) {
        if (confirm("Are you sure you want to Delete "+ text +"?")) {
          database.transaction(function(tx) {
            tx.executeSql('DELETE FROM tasks WHERE id=?', [id]);
          });
          showAll();
        }
  </pre>

  <h4>IndexedDB - delete data</h4>
  <p>
    Start a transaction, reference the Object Store with your object in and issue a delete 
    command with the unique ID of your object.
  </p>

  <pre class="prettyprint">  
    indexedDB.deleteTodo = function(id, text) {
     if (confirm("Are you sure you want to Delete "+ text +"?")) {
        var db = todoDB.indexedDB.db;
        var trans = db.transaction(["todo"], IDBTransaction.READ_WRITE);
        var store = trans.objectStore("todo");


        var request = store.delete(id);


        request.onsuccess = function(e) {
          todoDB.indexedDB.getAllTodoItems();
        };


        request.onerror = function(e) {
          console.log("Error Adding: ", e);
        };
     }
    };
  </pre>

  <h3 id="toc-topic-subtopic">The Full Code</h3>

  <p>you can find the full code on github: <a href="https://github.com/greenido/WebSQL-to-IndexedDB-example">
      https://github.com/greenido/WebSQL-to-IndexedDB-example</a>
    and here is a 
    <a href="http://ido-green.appspot.com/WebSQL-IndexedDB-example/main.html" target="_blank">live example.</a>
  </p>

  <h3 id="toc-topic-subtopic">Epilogue</h3>
  <p>
    On November 18, 2010, the W3C announced that Web SQL database is a deprecated specification. 
    This is a recommendation for web developers to no longer use the technology as effectively the spec 
    will receive no new updates and browser vendors aren't encouraged to support this technology. 
    The replacement is IndexedDB. As we saw it’s very different from relational databases and as ‘NoSQL’ 
    database it give us lots of power. IndexedDB let us create an Object Store for a type of data and simply
    persist Javascript Objects to that store. Each Object Store can have a collection of Indexes that make 
    it efficient to query and iterate across. 
    <br/>
    So it wasn’t painful as you thought it would be, right? 
  </p>


  <h2 id="toc-references">References</h2>
  <ul>
    <li><a href="https://developer.mozilla.org/en/IndexedDB">Mozilla developer network - IndexedDB</a></li>
    <li><a href="http://www.w3.org/TR/IndexedDB/">IndexedDB - Spec on W3</a></li>
    <li><a href="http://www.w3.org/TR/webdatabase/">Web SQL - Spec on W3</a></li>
    <li><a href="http://www.html5rocks.com/en/tutorials/indexeddb/todo/">Simple todo list - IndexedDB</a></li>
  </ul>

  {% endblock %}
